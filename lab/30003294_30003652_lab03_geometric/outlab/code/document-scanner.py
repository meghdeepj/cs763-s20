import cv2
import numpy as np
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-i", help="p values for p norm")

args = parser.parse_args()

img = cv2.imread(args.i)

cv2.namedWindow("input",cv2.WINDOW_NORMAL)
cv2.resizeWindow("input",700,700)
cv2.imshow("input",img)
cv2.waitKey(0)


# Checking if the image was taken in landscape mode if yes we convert it to potrait mode
if img.shape[0] < img.shape[1]:
	img = np.rot90(img)

gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
gray = cv2.medianBlur(gray,7) 
# Added median filer to remove salt and pepper type of effect on shiny black background

# Applying gaussian blur to reduce unwanted edges dueto noise
gray = cv2.GaussianBlur(gray,(3,3),cv2.BORDER_DEFAULT)
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(4,4))
gray = clahe.apply(gray)

kernel = np.ones((7,7),np.uint8)
edge = cv2.Canny(gray,40,100)
edge = cv2.dilate(edge,kernel,iterations = 1)

try:
	contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
	sortedCountours = sorted(contours, key=cv2.contourArea, reverse=True)
except:
	print("Unable to detect contours")
	exit(-1)


# Creating a blank image for generating filled polygon generated by 
# the largest detected contour (one corresponding to the document)
canvas = img*0

cnt = sortedCountours[0]

# Avoiding uneven edges and approximating the contour to a quadrilateral
epsilon = 0.1*cv2.arcLength(cnt,True)
hull = cv2.approxPolyDP(cnt,epsilon,True)

canvas = img*0

cv2.drawContours(canvas,[hull],0,(255,255,255),-1)

# Storing all the values in a numpy array
cornerPts = hull.reshape(-1,2)

xsort = cornerPts[np.argsort(cornerPts[:,0])]
ysort = cornerPts[np.argsort(cornerPts[:,1])]

try:
	# """
	# Deciding the order of the corner points
	# Step1. Finding the topmmost two corners and comparing thier x values to find top left and top right corners
	# Step2. Similar method for bottom points
	p0 = ysort[:-2][np.argmin(ysort[:2,0])]
	p1 = ysort[:-2][np.argmax(ysort[:2,0])]
	p2 = ysort[-2:][np.argmax(ysort[-2:,0])]
	p3 = ysort[-2:][np.argmin(ysort[-2:,0])]
	# """
except:
	print("Desired shape of contour is not detected")
	exit(-1)

h,w = img.shape[:2]

original_pts = np.float32([p0,p1,p2,p3])
desired_pts = np.float32([[0,0],[w,0],[w,h],[0,h]])

M = cv2.getPerspectiveTransform(original_pts,desired_pts)

output = cv2.warpPerspective(img,M,(w,h))

cv2.namedWindow("output",cv2.WINDOW_NORMAL)
cv2.resizeWindow("output",700,700)
cv2.imshow("output",output)
cv2.waitKey(0)