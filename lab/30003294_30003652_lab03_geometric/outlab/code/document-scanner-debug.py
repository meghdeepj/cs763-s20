import cv2
import numpy as np
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-i", help="p values for p norm")

args = parser.parse_args()


DEBUG_MODE = True

img = cv2.imread(args.i)

cv2.namedWindow("input",cv2.WINDOW_NORMAL)
cv2.resizeWindow("input",700,700)
cv2.imshow("input",img)
cv2.waitKey(0)


# Checking if the image was taken in landscape mode if yes we convert it to potrait mode
if img.shape[0] < img.shape[1]:
	img = np.rot90(img)

gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
gray = cv2.medianBlur(gray,7) 
# Added median filer to remove salt and pepper type of effect on shiny black background

# Applying gaussian blur to reduce unwanted edges dueto noise
gray = cv2.GaussianBlur(gray,(3,3),cv2.BORDER_DEFAULT)
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(4,4))
gray = clahe.apply(gray)

if DEBUG_MODE:
	cv2.namedWindow("input for edge detection",cv2.WINDOW_NORMAL)
	cv2.resizeWindow("input for edge detection",700,700)
	cv2.imshow("input for edge detection",gray)
	cv2.waitKey(0)


kernel = np.ones((7,7),np.uint8)
edge = cv2.Canny(gray,40,100)
edge = cv2.dilate(edge,kernel,iterations = 1)

if DEBUG_MODE:
	cv2.namedWindow("output of edge detection",cv2.WINDOW_NORMAL)
	cv2.resizeWindow("output of edge detection",700,700)
	cv2.imshow("output of edge detection",edge)
	cv2.waitKey(0)

try:
	contours, hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
	sortedCountours = sorted(contours, key=cv2.contourArea, reverse=True)
	"""
	# To display ll the detected contours
	for cnt in sortedCountours:
		cv2.drawContours(canvas,[cnt],0,(255,255,255),-1)
		cv2.imshow(WINDOW_NAME,canvas)
		cv2.waitKey(0)
	"""
except:
	print("Unable to detect contours")
	exit(-1)


# Creating a blank image for generating filled polygon generated by 
# the largest detected contour (one corresponding to the document)
canvas = img*0

cnt = sortedCountours[0]

# Avoiding uneven edges and approximating the contour to a quadrilateral
epsilon = 0.1*cv2.arcLength(cnt,True)
hull = cv2.approxPolyDP(cnt,epsilon,True)

canvas = img*0

cv2.drawContours(canvas,[hull],0,(255,255,255),-1)

if DEBUG_MODE:
	cv2.namedWindow("largest contour",cv2.WINDOW_NORMAL)
	cv2.resizeWindow("largest contour",700,700)
	cv2.imshow("largest contour",canvas)
	cv2.waitKey(0)

# Storing all the values in a numpy array
cornerPts = hull.reshape(-1,2)

xsort = cornerPts[np.argsort(cornerPts[:,0])]
ysort = cornerPts[np.argsort(cornerPts[:,1])]

# """
# Deciding the order of the corner points
# Step1. Finding the topmmost two corners and comparing thier x values to find top left and top right corners
# Step2. Similar method for bottom points
p0 = ysort[:-2][np.argmin(ysort[:2,0])]
p1 = ysort[:-2][np.argmax(ysort[:2,0])]
p2 = ysort[-2:][np.argmax(ysort[-2:,0])]
p3 = ysort[-2:][np.argmin(ysort[-2:,0])]
# """

if DEBUG_MODE:
	# Displaying extreme points
	cv2.namedWindow("Displaying corners in order",cv2.WINDOW_NORMAL)
	cv2.resizeWindow("Displaying corners in order",700,700)
	cv2.circle(canvas,tuple(ysort[:-2][np.argmin(ysort[:2,0])]),20,(255,255,255),-1)
	cv2.imshow("Displaying corners in order",canvas)
	cv2.waitKey(0)
	cv2.circle(canvas,tuple(ysort[:-2][np.argmax(ysort[:2,0])]),20,(0,0,255),-1)
	cv2.imshow("Displaying corners in order",canvas)
	cv2.waitKey(0)
	cv2.circle(canvas,tuple(ysort[-2:][np.argmax(ysort[-2:,0])]),20,(0,255,0),-1)
	cv2.imshow("Displaying corners in order",canvas)
	cv2.waitKey(0)
	cv2.circle(canvas,tuple(ysort[-2:][np.argmin(ysort[-2:,0])]),20,(255,0,0),-1)
	cv2.imshow("Displaying corners in order",canvas)
	cv2.waitKey(0)


h,w = img.shape[:2]

original_pts = np.float32([p0,p1,p2,p3])
desired_pts = np.float32([[0,0],[w,0],[w,h],[0,h]])

M = cv2.getPerspectiveTransform(original_pts,desired_pts)

output = cv2.warpPerspective(img,M,(w,h))

cv2.namedWindow("output",cv2.WINDOW_NORMAL)
cv2.resizeWindow("output",700,700)
cv2.imshow("output",output)
cv2.waitKey(0)
